DEVELOPMENT OF AN ELEVATOR PROJECT

    In this project I developed a project in which I used Aurix boards and Arduino elements. 
    The goal of this project was to implement an elevator that goes up and down 3 levels controlled by a button.


MEDICAL PREDICTIONS USING ARTIFICIAL NEURAL NETWORKS

    The diploma work I did to complete my studies was entitled " Medical predictions using artificial neural networks". 
    The application that I implemented in Matlab has the role of making predictions regarding the risk of developing heart problems.

    Heart problems are of several types such as typical angina, atypical angina and can occur due to the fat that accumulates on the blood vessels of people. 
    The application was implemented in the Matlab development environment using Artificial Neural Networks, Elementary Neurons and some tools offered by this system such as: Neural Net Fitting and App Designer.


PORTABLE HEALTH MONITORING SYSTEM.

In the framework of this project carried out in the 1st year of the master's degree in the 2nd semester, together with my teammates, I created a portable (wearable) system for health monitoring. It will follow the evolution of elderly beneficiaries (patients). The system
it will monitor the evolution of some physiological parameters (ECG, humidity, temperature, pulse) through measurements from sensors, and if the values ​​read for a certain patient do not fall within the normal values, then it will receive different warnings on the Smartphone.
The system will allow the connection of several doctors to the application for
entering/viewing the patient record and monitoring and also of several patients.

The created system was composed of 4 modules:
- application for entering/viewing the patient record and monitoring
- cloud component
- mobile application
- the intelligent module that will collect the data from the sensors (ECG, humidity, temperature, pulse).

The application for entering/viewing the patient record and monitoring will be
accessible on the web. Within it, a specialist doctor (cardiologist) can
enter/view the patient's file and subsequently monitor its evolution and the patient's
he will be able to view his data. 

The doctor or the patient will be able to view different
information taken from the sensors with the help of some graphs and to generate different ones
reports. The doctor will also be able to introduce recommendations that the patient will
must follow them (e.g. cycling, running, walking, certain physical exercises,
etc.). 

Based on the doctor's recommendations, the system will have to provide the display
them on the Smartphone. The web application will be able to do the following:
a. The doctor will be able to add a new patient; the data entered will be:
- Demographic data (name, surname, age, CNP, address - divided by
fields, phone number, email address, profession, workplace)
- Medical data (medical history, allergies, cardiological consultations - in format
text)
b. The doctor will be able to modify, delete or view the patient's data, as well as
history and patient progress graphs, including alarms/warnings
and will enter the normal values ​​for the smart module, this will be
customized for each patient.
c. The patient will be able to view his own record, the recommendations given by the doctor and
a history of activities and read values, including in the form of graphs,
respectively a history of alarms/warnings created by the doctor and recorded in
monitoring framework.
d. The cardiologist will be able to do classic face-to-face consultations, and in the record
the patient will be recorded the reason for presentation, symptoms, diagnosis
(coded ICD-10), referrals (to tests, to the hospital, to treatments, to procedures),
generated recipes. The doctor will be able to see the previous consultations, in the form
tabular.

The cloud component will allow to:
a. record of users and associations; thus, the system will allow its use by several doctors, each doctor having a number of patients; each doctor will only be able to access the information of his own patients; the system will uniquely associate a patient with a Smartphone and with the set of sensors;
b. storing and accessing the data from the patient's file, by the user doctors and by the patients, through the WEB interface.
c. reception and storage of information received from the intelligent module through
via Smartphone;
d. receiving and storing other information sent by the Smartphone,
e. storing and transmitting recommendations and alarms/warnings defined by
doctor to the mobile application;
f. receiving and storing activated alarms/warnings on patients' Smartphones.


The mobile application will be made for Android smartphones and will have the possibility to:
a. display the activities that the patient will have to perform and their calendar;
b. display the doctor's recommendations;
c. signal the warnings created by the mobile application according to the warning models established by the doctor, if data is received by the intelligent module that is not within the normal value; alerts are created based on measurements at 10 s intervals.
d. will receive the information from the intelligent module through the Bluetooth connection and send it to the cloud component; data will be sent at intervals of 30 seconds as an average of the measurements at 10 seconds; if the data received from the smart module will be outside the normal limits, it will be sent asynchronously - at the time of the alarm/warning - to the cloud;
e. read the data from the accelerometer, once per second, to correlate this information with that read from the smart sensor, in order to establish alarm conditions; the data is sent at 30 second intervals, in its entirety, in the form of bursts (longer messages, which contain all the values);
f. allows entering a text associated with an alarm/warning, which will be sent asynchronously to the cloud, once the alarm is activated;

In the physical implementation of the project I used a more user-friendly configuration that contains the Arduino module.
The necessary components and technologies are the following:

- 1 Arduino Uno v3 module
- 1 Bluetooth Mate Silver connector for Arduino class 2
- 1 pulse sensor module
- 1 Cardiac Activity Monitor module
- Cable and medical electrodes
- 1 module Humidity and temperature sensors
- Arduino IDE development environment.



During the faculty I did exercises and projects in which I had to write code and I had to solve requirements such as: reading, displaying, sorting, deleting, etc.



EDUCATIONAL PLATFORM CREATION:

Within this project, we have developed a platform similar to a Virtual Campus where students from a university can access courses and find out their grades for the subjects they are enrolled in.

An educational platform such as Virtual Campus usually contains the following elements and functionalities:

Course management:

Creating and organizing courses.
Upload course materials (documents, presentations, videos).
Configuring the course structure (modules, lessons, assignments).

Assessment tools:

Creating online tests and exams.
Features for automatic assessment and instant feedback.
Grading systems and student performance management.

Communication and collaboration:

Discussion forums for students and teachers.
Internal messaging system.
Group workspaces for collaborative projects.

User management:

Create and manage accounts for students, teachers and administrators.
Managing user rights and roles.
Monitoring user activity and generating reports.

Educational Resources:

Digital library with access to articles, books and other educational resources.
Integration with other online resource platforms (eg university libraries, scientific databases).

Online Learning Support:

Video conferences and webinars.
Tools for recording and sharing video lessons.
Interactive activities and simulations.

Customization and flexibility:

Customizing the user interface and graphic themes.
Tailoring the content and learning experience to each user's needs.

Integration with other systems:

Connecting with learning management systems (LMS) such as Moodle or Blackboard.
Integration with student data management systems (SIS).
Synchronization with external calendars and programs.

Support and security:

Technical assistance and user support.
Data backup and restore functionality.
Security measures to protect user data.

Analytics and reports:

Detailed analyzes of student progress and performance.
Custom reports for teachers and administrators.
Interactive dashboards for real-time monitoring of activities on the platform.
These components are part of the infrastructure of a comprehensive educational platform, designed to facilitate the teaching and learning process in the online environment.



PROJECT DEVELOPMENT USING VARIOUS TECHNOLOGICAL ENVIRONMENTS:
- Butterworth filter
- Level adaptation
- Electronic filter
- Interpolation



THE EVOLUTION OF THE FOOTBALL TEAM F.C. BARCELONA USING MATLAB'S PREDICT FUNCTION FOR A SET OF DATA USING CURVE FITTING:

INTRODUCTION:

The project topic addressed in the discipline of Systems Identification is the study of the evolution of a football team in the Spanish championship La Liga Santander with the help of a prediction function in MATLAB for a given set of data.
With the help of this prediction we can predict the outcome of a model in the future using past measurements.

THEORETICAL AND PRACTICAL DEVELOPMENT:

Thus, we know the number of stages played by the team is 32 and we know how many points the team had after each stage.
We are going to specify how many points the team will have at the end of the football season, i.e. after 6 more stages, based only on the data set we had.
To begin with, we will create two matrices that will contain the number of stages played in the Spanish championship and the number of points accumulated at each stage:

etape=[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32];
puncte=[3;6;9;10;13;13;14;14;14;14;17;20;20;23;26;29;30;30;33;36;39;42;45;45;48;48;51;54;57;57;58;61];

The variable curvefit is declared as the polynomial curve of the 3rd degree with the arguments stages and points and the graph is displayed which has on the right x the number of stages played so far, and on y the number of points summed up after the result of each stage: [function. fit]
curvefit=fit(etape,puncte,'poly3','normalize','on')
plot(curvefit,etape,puncte);

The graph in Matlab: evidence of stages/points

In the following, the graph will be displayed to which the prediction limits are added using the following command in Matlab: plot(curvefit,stages,points,'predfunc');

Chart in Matlab: prediction bounds

We want to find out how many points the F.C. team will have. Barcelona at the end of the football season, i.e. after the completion of the 38 stages.
We will need to display the graph with the prediction of the next 6 legs that have not been played yet and also the prediction of the number of points:
To solve this case we will have to use the following commands:
plot(steps,points,'o')
xlim([1,38])
hold on plot(curvefit,'predobs')
hold off

Graph in Matlab: the number of possible points obtained after the 38 stages

We will display a Fourier Series graph using the command in Matlab: curvefitfourier=fit(steps, points, 'fourier8','normalize','on'); plot(curvefitfourier,stages,points);

We will display a Sum of Sines graph using the command in Matlab: curvefitsinus=fit(steps, points, 'sin8','normalize','on'); plot(fitsine curve, stages, points);

We will graph the Polynomial Function of Degree 2 using the command in Matlab:
curvefitpol2=fit(steps, points, 'poly2','normalize','on'); plot(curvefitpol2,steps,points);


- With the help of Curve Fitting we were able to obtain a graph in which we observed on the two axes X and Y the exact values ​​that led to the subsequent anticipation of the results.
- Using various functions in the Matlab application I was able to display the prediction limits and anticipate the possible number of points after the 6 stages, i.e. until the end of the season based only on the given set of values.
- I also used other commands in Matlab to display graphs with Fourier Series, Sum of Sines and Polynomial of degree 2. I noticed how the fitted curve changes its shape.



COMPLEX AUTOMATIONS:

For the application part, I decided to simulate with the Matlab-Simulink application the scheme with number 1 from the first laboratory. The diagram shows "Starting a Synchronous Motor".

With the help of the Matlab programming environment and the Simulink tool, I will study the effects that the synchronous motor can have when the operating parameters change and the evolution of the quantities of interest.

- The oscilloscope's role is to help us observe the 6 signals that led our simulation to the desired final results.
- The motor will need to be connected to a three-phase voltage source to observe changes in the rotor speed and the current passing through the rotor winding.
- The supply voltage values ​​will change with the aim of observing in which starting stage the synchronous motor will be.



ENDLESS RUN

EndlessRun is an endless runner game in which the player is challenged to run continuously, avoiding obstacles along the way. 
The main goal of the game is to get as high a score as possible by guiding the character through the wall corresponding to the color of the wall and enduring as long as possible. 
The popularity of this genre of games has been significantly influenced by the success of the 'Temple Run' and 'Jetpack Joyride' titles, both of which have become representative of the endless runner category. 
The game has two main scenes, available in a directory called "Scenes": the "Game" scene, which contains the main menu, and the "Shop" scene, which is the accessory shop.


First scene: Main menu

This scene displays the game menu, including: the start button, the game title, the balance of coins collected, the maximum score, the Shop button and the Exit button. 
The menu is stylized with a background consisting of an image representative of the game, with buttons and text superimposed. 
The game title, "EndlessRun", is placed at the top, centered, using a black robotic font. The coin bar, colored in blue, contains a suggestive image of a coin, and the high score is displayed in a dedicated bar, complemented by an image symbolizing first place.
At the bottom are the start, store and exit buttons. The yellow start button includes the text "Play" and a script to start the game. 
The Shop button and Exit button have similar functions, each with a specific script: "Shop()" for the Shop button and close application for the Exit button.
When the "Start" button is pressed, the menu disappears and the character animation starts, representing the character running on a dynamically generated path. 
The character automatically moves forward and the player can only control left-right movement to avoid obstacles. 
Score is accumulated by avoiding obstacles and collecting coins, which can be used for purchases in the shop.

Second scene: Accessories shop

The Shop scene has a purple background and shows the main character without accessories. 
To the side are the "Next" and "Previous" buttons, used for navigating through the list of accessories. 
Selected accessories are displayed in the center, with "Select" and "Buy" buttons underneath, along with the price of each accessory. 
If the accessory is purchased, the "Select" button equips the character with it and returns to the main scene. 
In case of insufficient funds, the "Buy" button becomes unavailable and changes color. The game ends when the player fails to avoid obstacles or pass through the correct wall.

We tested the app and found that the player's speed reaches too high a value shortly after starting the game, making the game impossible in bypassing obstacles .
I redid the formula for player speed and changed the movement speed value to a lower value .

The balance of coins is the sum of the number of gates (colored walls) reached. Passing through a gate is equivalent to 5 coins. 
The score is the sum of coins collected and gates reached, so one coin collected is equivalent to 3 points and one gate is equivalent to 10 points.



SCRIPT:

TrackManager.cs

This script tracks the progress of the game. We initialize the plane's movement speed ("track"), which can be configured from the interface; we set the "wallHolder" object to null and assign it the "WallHolder" object; we create a list of materials to represent the colors of the blocks in the "wallHolder"; initialize an object of type "ParticleSystem" to generate visual effects following the collision of the player with the gates; set and initialize to null an object of type "TrackManager"; create a list of type "MeshRender" to manage the colors of the walls that form the gate and initialize a variable that refers to the gate.
The void type Start() function assigns each block in the "wallHolder" a color from the material list and checks if the player has passed through the gate in the active track. 
If so, we call the ColorChanger() function, which will change the player's color.
In the ColorChanger() function, we create a new material list, add the existing material colors to it, randomly set the order of the materials in the list, and remove the first material when it reaches position -1. 
We set the "Gate" tag for the "gate" object and adjust the player color to match the gate color.
The BurstGate() function takes two parameters: "pos" of type Vector3 and "mat" of type Material. 
With this function, the position of the effects is set to match the player's position, the particle effects are activated, and the particle is assigned the color of the block passed through.




GameUI.cs

This script is responsible for managing the user interface and various functions within EndlessRun. 
Using the script, UI elements such as score display, menu management and end-game interactions are coordinated. 
In the following, we detail its components and functionalities.



Implemented functionalities
1. Awake() method
- Role: Ensures existence of a single instance of the class (design pattern Singleton) and initializes previously saved values.
- Details:
o If an active instance of the class already exists, the current object is destroyed.
o The values for points are retrieved using PlayerPrefs, and the text for coins (cashText) is updated.
2. Start() method
- Role: Initializes the main menu interface at the start of the game.
- Details:
o The text for the best score is updated using the value in PlayerPrefs.
o Collected coins are displayed in the main menu.
3. Update() method
- Role: Dynamically updates the user interface throughout the game.
- Details:
o The scoreText is synchronized with the current score value.
o The coin text is updated in real-time.
4. StartBtn() method
- Role: Starts the game when the player presses the start button.
- Details:
o Enables the gameplay interface (gamePlayUI) and disables the main menu (gameMainMenu).
o Set the isGameStarted variable in CharacterController to true and starts the character's running animation.
5. RetryBtn() method
- Role: Enables resuming the game by reloading the current scene.
- Details:
o Uses the SceneManager to reload the active scene, resetting game progress.
6. Exit() method
- Role: Closes the application.
- Details:
o Calls the Application.Quit() function to close the game.
7. GameOverUI() method
- Role: Handles the end-game interface and updates score and coin values.
- Details:
o Disables the gameplay UI and enables the game over UI.
o Saves the current score and checks for a new record, updating HighScore if necessary.
o Displays motivational messages based on player performance:
 If score is over 200: congratul congratulatory message for excellent dexterity.
 If score is between 100 and 200: message of encouragement.
 If the score is below 100: suggestion for medical advice.
8. Shop() method
- Role: Navigates to the "Shop" scene, where the player can purchase accessories.
- Details:
o Uses the SceneManager to load the "Shop" scene.
Data Persistence: The script uses PlayerPrefs to save and retrieve score and coin values.
- Manage game states: It clearly delineates the logic of each state, such as the main menu, gameplay, and end interface.
- Personalized messages: Add a motivational and interactive element by displaying messages based on user performance.


RandomTile.cs

This script controls the random generation of tiles in an endless runner game. 
Its functionality ensures that the game environment is dynamic, expands ahead of the player and removes unused tiles behind the player to optimize performance.

Variables declared:
1. public GameObject[] prefab:
o Array containing the various prefabs for the path pieces.
o Each piece represents a section of the path to be dynamically generated.
2. public float zSpawn = 0f:
o The z coordinate where the next piece will be placed.
o Initially set to 0.
3. public float tilelenght = 50f:
o The length of each tile.
o Each piece is placed following the other on the z-axis.
4. public int numberOfTile = 4:
o The number of simultaneously active tiles on the trail.
5. public Transform playerTransform:
o Player position reference used to decide when to generate new pieces.
6. private List<GameObject> activeTiles:List that holds the currently active tiles on the path.




Functionality of the main methods
1. Start()
- Role: Initializes the game path by generating a set of pieces at the start.
- Implementation:
o Generate the first 4 tiles (holding the numberOfTile value).
o The first piece is always generated using index 0 (default template).
o The rest of the pieces are randomly chosen from the prefab array.
2. Update()
- Role: Monitors the player's position and generates new pieces in front of the player as it advances.
- Implementation:
o If the player's position minus 50 exceeds the last zSpawn position minus the total length of active pieces, a new piece is generated.
o An inactive tile is deleted from the list using the DeletTiles() method.
3. SpawnManager(int tileIndex)
- Role: Creates a new tile on the path.
- Parameters:
o tileIndex: The index of the tile in the prefab array to generate.
- Implementation:
o Instantiates a tile at the position defined by zSpawn.
o The generated part is added to the list.
o The zSpawn value is incremented by tilelenght to set the position of the next part.
4. DeletTiles()
- Role: Removes the first tile in the list (furthest from the player) to optimize resources.
- Implementation:
o Deletes the object in the first position of the activeTiles list.
o The reference to this object is removed from the list using RemoveAt(0).




1.	Optimization:
o Removing inactive tiles via the DeleteTiles() method prevents unnecessary object accumulation and excessive memory consumption.

2.	Flexibility:
o The path is dynamic, and tile variety is provided by random selection from the prefab array.

3.	Player-based control:
o The player's position determines when new tiles are generated, which ensures game continuity and avoids unnecessary generation.








